#!/usr/bin/env python3
import sys
import pygame

def collectGridData(screen, height, width, blockSize, info):
	total = info[0]["total"]
	y_count = 0
	for y in range(0, height, blockSize):
		x_count = 0
		for x in range(0, width, blockSize):
			i = 0
			while i < total:
				if info[i]["x"] == x_count and info[i]["y"] == y_count:
					info[i]["grid_x"] = x + int(blockSize)
					info[i]["grid_y"] = y + int(blockSize)
					break
				i += 1
			x_count += 1
		y_count += 1

def no_ants_on_start(count, moves):
	i = 0
	total = int(moves[0]["total_ants"]) - 1
	if count < total:
		return (False)
	return (True)

def drawGrid(screen, height, width, blockSize, info, start, end, count, moves):
	total = info[0]["total"]
	y_count = 0
	for y in range(0, height, blockSize):
		x_count = 0
		for x in range(0, width, blockSize):
			#rect = pygame.Rect(x, y, blockSize, blockSize)
			#pygame.draw.rect(screen, (200, 200, 200), rect, 1)
			#only do below if it is one of the rooms
			i = 0
			while i < total:
				if info[i]["x"] == x_count and info[i]["y"] == y_count:
					rect = pygame.Rect(x, y, blockSize, blockSize)
					if info[i]["nbr"] == start:
						color = (0, 0, 200)
					elif info[i]["nbr"] == end:
						color = (0, 200, 0)
					else:
						color = (200, 200, 200)
					pygame.draw.rect(screen, color, pygame.Rect(x + int(blockSize), y + int(blockSize), blockSize, blockSize))
					font=pygame.font.SysFont('arial', blockSize)
					if info[i]["nbr"] == "start":
						print_nbr = "s"
					elif info[i]["nbr"] == "end":
						print_nbr = "e"
					else:
						print_nbr = info[i]["nbr"]
					text=font.render(print_nbr, True, (0, 0, 0))
					rect=text.get_rect()
					screen.blit(text, [x + int(blockSize), y + int(blockSize)])
					if info[i]["nbr"] == start and no_ants_on_start(count, moves) == False:
						pygame.draw.circle(screen, (0, 0, 0), [info[i]["grid_x"] + int(blockSize) / 2, info[i]["grid_y"] + int(blockSize) / 2], int(blockSize) / 3, 3)
					break
				i += 1
			x_count += 1
		y_count += 1

def check_if_anything_block_x(info, j, k):
	i = 0
	total = info[i]["total"]
	while i < total:
		if info[i]["x"] > info[j]["x"] and info[i]["x"] < info[k]["x"] and info[i]["y"] == info[j]["y"]:
			return (True)
		if info[i]["x"] < info[j]["x"] and info[i]["x"] > info[k]["x"] and info[i]["y"] == info[j]["y"]:
			return (True)
		i += 1
	return (False)

def check_if_anything_block_y(info, j, k):
	i = 0
	total = info[i]["total"]
	while i < total:
		if info[i]["y"] > info[j]["y"] and info[i]["y"] < info[k]["y"] and info[i]["x"] == info[j]["x"]:
			return (True)
		if info[i]["y"] < info[j]["y"] and info[i]["y"] > info[k]["y"] and info[i]["x"] == info[j]["x"]:
			return (True)
		i += 1
	return (False)

def special_connect_draw_y(screen, blockSize, info, i, k):
	if check_if_anything_block_x(info, i, k) == True and info[i]["grid_x"] < info[k]["grid_x"]:
		pygame.draw.line(screen, (100, 100, 100), (info[i]["grid_x"] + int(blockSize / 2), info[i]["grid_y"] + int(blockSize / 2)), (info[i]["grid_x"] + int(blockSize / 2) + int(blockSize), info[i]["grid_y"] + int(blockSize / 2) + int(blockSize)), 20)
		pygame.draw.line(screen, (100, 100, 100), (info[i]["grid_x"] + int(blockSize / 2) + int(blockSize), info[i]["grid_y"] + int(blockSize / 2) + int(blockSize)), (info[k]["grid_x"] + int(blockSize / 2) - int(blockSize), info[k]["grid_y"] + int(blockSize / 2) + int(blockSize)), 20)
		pygame.draw.line(screen, (100, 100, 100), (info[k]["grid_x"] + int(blockSize / 2) - int(blockSize), info[k]["grid_y"] + int(blockSize / 2) + int(blockSize)), (info[k]["grid_x"] + int(blockSize / 2), info[k]["grid_y"] + int(blockSize / 2)), 20)
	elif check_if_anything_block_x(info, i, k) == True and info[i]["grid_x"] > info[k]["grid_x"]:
		pygame.draw.line(screen, (100, 100, 100), (info[i]["grid_x"] + int(blockSize / 2), info[i]["grid_y"] + int(blockSize / 2)), (info[i]["grid_x"] + int(blockSize / 2) - int(blockSize), info[i]["grid_y"] + int(blockSize / 2) - int(blockSize)), 20)
		pygame.draw.line(screen, (100, 100, 100), (info[i]["grid_x"] + int(blockSize / 2) - int(blockSize), info[i]["grid_y"] + int(blockSize / 2) - int(blockSize)), (info[k]["grid_x"] + int(blockSize / 2) + int(blockSize), info[k]["grid_y"] + int(blockSize / 2) - int(blockSize)), 20)
		pygame.draw.line(screen, (100, 100, 100), (info[k]["grid_x"] + int(blockSize / 2) + int(blockSize), info[k]["grid_y"] + int(blockSize / 2) - int(blockSize)), (info[k]["grid_x"] + int(blockSize / 2), info[k]["grid_y"] + int(blockSize / 2)), 20)
	else:
		pygame.draw.line(screen, (100, 100, 100), (info[i]["grid_x"] + int(blockSize / 2), info[i]["grid_y"] + int(blockSize / 2)), (info[k]["grid_x"] + int(blockSize / 2), info[k]["grid_y"] + int(blockSize / 2)), 20)

def special_connect_draw_x(screen, blockSize, info, i, k):
	if check_if_anything_block_y(info, i, k) == True and info[i]["grid_y"] < info[k]["grid_y"]:
		pygame.draw.line(screen, (100, 100, 100), (info[i]["grid_x"] + int(blockSize / 2), info[i]["grid_y"] + int(blockSize / 2)), (info[i]["grid_x"] + int(blockSize / 2) + int(blockSize), info[i]["grid_y"] + int(blockSize / 2) + int(blockSize)), 20)
		pygame.draw.line(screen, (100, 100, 100), (info[i]["grid_x"] + int(blockSize / 2) + int(blockSize), info[i]["grid_y"] + int(blockSize / 2) + int(blockSize)), (info[k]["grid_x"] + int(blockSize / 2) + int(blockSize), info[k]["grid_y"] + int(blockSize / 2) - int(blockSize)), 20)
		pygame.draw.line(screen, (100, 100, 100), (info[k]["grid_x"] + int(blockSize / 2) + int(blockSize), info[k]["grid_y"] + int(blockSize / 2) - int(blockSize)), (info[k]["grid_x"] + int(blockSize / 2), info[k]["grid_y"] + int(blockSize / 2)), 20)
	elif check_if_anything_block_y(info, i, k) == True and info[i]["grid_y"] > info[k]["grid_y"]:
		pygame.draw.line(screen, (100, 100, 100), (info[i]["grid_x"] + int(blockSize / 2), info[i]["grid_y"] + int(blockSize / 2)), (info[i]["grid_x"] + int(blockSize / 2) - int(blockSize), info[i]["grid_y"] + int(blockSize / 2) - int(blockSize)), 20)
		pygame.draw.line(screen, (100, 100, 100), (info[i]["grid_x"] + int(blockSize / 2) - int(blockSize), info[i]["grid_y"] + int(blockSize / 2) - int(blockSize)), (info[k]["grid_x"] + int(blockSize / 2) - int(blockSize), info[k]["grid_y"] + int(blockSize / 2) + int(blockSize)), 20)
		pygame.draw.line(screen, (100, 100, 100), (info[k]["grid_x"] + int(blockSize / 2) - int(blockSize), info[k]["grid_y"] + int(blockSize / 2) + int(blockSize)), (info[k]["grid_x"] + int(blockSize / 2), info[k]["grid_y"] + int(blockSize / 2)), 20)
	else:
		pygame.draw.line(screen, (100, 100, 100), (info[i]["grid_x"] + int(blockSize / 2), info[i]["grid_y"] + int(blockSize / 2)), (info[k]["grid_x"] + int(blockSize / 2), info[k]["grid_y"] + int(blockSize / 2)), 20)

def drawConnections(screen, height, width, blockSize, info):
	total = info[0]["total"]
	y_count = 0
	for y in range(0, height, blockSize):
		x_count = 0
		for x in range(0, width, blockSize):
			i = 0
			while i < total:
				if info[i]["x"] == x_count and info[i]["y"] == y_count:
					j = 0
					len_of_connect = len(info[i]["connect"])
					while j < len_of_connect:
						k = 0
						while k < total:
							if info[i]["connect"][j] == info[k]["nbr"]:
								if info[i]["grid_y"] == info[k]["grid_y"]:
									special_connect_draw_y(screen, blockSize, info, i, k)
								elif info[i]["grid_x"] == info[k]["grid_x"]:
									special_connect_draw_x(screen, blockSize, info, i, k)
								else:
									pygame.draw.line(screen, (100, 100, 100), (info[i]["grid_x"] + int(blockSize / 2), info[i]["grid_y"] + int(blockSize / 2)), (info[k]["grid_x"] + int(blockSize / 2), info[k]["grid_y"] + int(blockSize / 2)), 20)
							k += 1
						j += 1
					break
				i += 1
			x_count += 1
		y_count += 1

def draw_ant(screen, height, width, blockSize, info, start, end, moves, current_move):
	total = info[0]["total"]
	total_moves = len(moves[current_move]["room"])
	y_count = 0
	for y in range(0, height, blockSize):
		x_count = 0
		for x in range(0, width, blockSize):
			i = 0
			while i < total:
				if info[i]["x"] == x_count and info[i]["y"] == y_count:
					j = 0
					while j < total_moves:
						if moves[current_move]["room"][j] == info[i]["nbr"]:
							if moves[current_move]["ant"][j] % 2 == 0:
								color = (0, 0, 200)
							elif moves[current_move]["ant"][j] % 3 == 0:
								color = (0, 200, 0)
							else:
								color = (200, 0, 0)
							pygame.draw.circle(screen, color, [info[i]["grid_x"] + int(blockSize) / 2, info[i]["grid_y"] + int(blockSize) / 2], int(blockSize) / 3, 3)
						j += 1
					break
				i += 1
			x_count += 1
		y_count += 1

def drawText(screen, height, width, blockSize, prev, count, moves):
	font=pygame.font.SysFont('arial', blockSize)
	text=font.render(str(prev + 1) + "/" + str(moves[0]["total"]), True, (0, 0, 0))
	rect=text.get_rect()
	screen.blit(text, [0 + (int(blockSize) / 2), height - int(blockSize)])
	text=font.render(str(count + 1) + "/" + str(moves[0]["total"]), True, (200, 200, 200))
	rect=text.get_rect()
	screen.blit(text, [0 + (int(blockSize) / 2), height - int(blockSize)])

def make_map(start, end, info, moves):
	i = 0
	total = info[i]["total"]
	minX = info[i]["x"]
	maxX = info[i]["x"]
	minY = info[i]["y"]
	maxY = info[i]["y"]
	while i < total:
		print(info[i])
		if info[i]["x"] < minX:
			minX = info[i]["x"]
		if info[i]["x"] > maxX:
			maxX = info[i]["x"]
		if info[i]["y"] < minY:
			minY = info[i]["y"]
		if info[i]["y"] > maxY:
			maxY = info[i]["y"]
		i += 1
	total = moves[0]["total"]
	i = 0
	while i < total:
		print(moves[i])
		i += 1
	black = (0, 0, 0)
	# Define the dimensions of
	# screen object(width,height)
	if maxX > 50 or maxY > 50:
		blockSize = 20 #Set the size of the grid block
	elif maxX > 20 or maxY > 20:
		blockSize = 40
	else:
		blockSize = 60
	window_height = 800
	window_width = 1200
	pygame.init()
	screen = pygame.display.set_mode((window_width, window_height))
	
	# Set the caption of the screen
	pygame.display.set_caption('Lem-in')
	
	# Fill the background colour to the screen
	screen.fill(black)

	pygame.display.update()

	# Update the display using flip
	#pygame.display.flip()
	
	# game loop
	count = -1
	prev = 0
	space = False
	while True:
		if count <= -1 and prev == 0:
			collectGridData(screen, window_height, window_width, blockSize, info)
			drawConnections(screen, window_height, window_width, blockSize, info)
			drawGrid(screen, window_height, window_width, blockSize, info, start, end, count, moves)
			drawText(screen, window_height, window_width, blockSize, prev, count, moves)
			prev = -1
		elif count != prev and count < moves[0]["total"]:
			drawConnections(screen, window_height, window_width, blockSize, info)
			drawGrid(screen, window_height, window_width, blockSize, info, start, end, count, moves)
			draw_ant(screen, window_height, window_width, blockSize, info, start, end, moves, count)
			drawText(screen, window_height, window_width, blockSize, prev, count, moves)
			prev = count
		if space == True and count < moves[0]["total"]:
			count += 1
			pygame.time.wait(250)
		if space == True and count == moves[0]["total"]:
			space = False
		for event in pygame.event.get():
			if event.type == pygame.KEYDOWN:
				if event.key == pygame.K_LEFT and count >= 0:
					count -= 1
				if event.key == pygame.K_RIGHT and count < moves[0]["total"]:
					count += 1
				if event.key == pygame.K_SPACE and count < moves[0]["total"]:
					if space == False:
						space = True
					elif space == True:
						space = False
				if event.key == pygame.K_r:
					count = -1
					prev = 0
			if event.type == pygame.QUIT:
				pygame.quit()
				sys.exit()
		pygame.display.update()


def check_if_coordinates(line):
	i = 0
	count = 0
	if line.count(" ") != 2:
		return (False)
	while i < len(line):
		if i == 0 and line.find("start") == 0:
			i += 5
			count += 1
		elif i == 0 and line.find("end") == 0:
			i += 3
			count += 1
		elif line[i] == " ":
			i += 1
		elif line[i].isnumeric() == True:
			if i == 0:
				count += 1
			elif line[i - 1] == " ":
				count += 1
			i += 1
		else:
			return (False)
	if count != 3:
		return (False)
	return (True)

def check_if_connection(line):
	i = 0
	count = 0
	if line.count("-") != 1:
		return (False)
	while i < len(line):
		if line.find("start") == i:
			i += 5
			count += 1
		elif line.find("end") == i:
			i += 3
			count += 1
		elif line[i] == "-":
			i += 1
		elif line[i].isnumeric() == True:
			if i == 0:
				count += 1
			elif line[i - 1] == "-":
				count += 1
			i += 1
		else:
			return (False)
	if count != 2:
		return (False)
	return (True)

def is_room(line, j, info, total):
	i = 0
	room = line[j:len(line)]
	k = 0
	while i < total:
		while info[i]["nbr"][k] == room[k] and room[k] != " ":
			k += 1
			return (True)
		i += 1
	return (False)

def check_if_ants_move(line, ants, info, total):
	i = 0
	l_found = False
	ant_found = False
	room_found = False
	while i < len(line):
		if line[i] == 'L' and l_found == False and ant_found == False and room_found == False:
			i += 1
			l_found = True
		elif line[i].isnumeric() == True and l_found == True and ant_found == False and room_found == False:
			nbr = line[i].partition("-")
			if int(nbr[0]) <= int(ants):
				ant_found = True
			else:
				return (False)
			i += 1
			while line[i].isnumeric() == True and i < len(line):
				i += 1
			if line[i] != '-':
				return (False)
			i += 1
		elif is_room(line, i, info, total) == True and l_found == True and ant_found == True and room_found == False:
			room_found = True
			while i < len(line) and line[i] != ' ':
				i += 1
		elif line[i] == ' ' and l_found == True and ant_found == True and room_found == True:
			l_found = False
			ant_found = False
			room_found = False
			i += 1
		else:
			return (False)
	if len(line) == 0:
		return (False)
	return (True)

def collect_ant_move(line, ants, info, total, moves, k):
	i = 0
	l_found = False
	ant_found = False
	room_found = False
	while i < len(line):
		if line[i] == 'L' and l_found == False and ant_found == False and room_found == False:
			i += 1
			l_found = True
		elif line[i].isnumeric() == True and l_found == True and ant_found == False and room_found == False:
			nbr = line[i].partition("-")
			moves[k]["ant"].append(int(nbr[0]))
			i += 1
			if int(nbr[0]) <= int(ants):
				ant_found = True
			else:
				return (False)
			while line[i].isnumeric() == True and i < len(line):
				i += 1
			if line[i] != '-':
				return (False)
			i += 1
		elif is_room(line, i, info, total) == True and l_found == True and ant_found == True and room_found == False:
			room_found = True
			j = 0
			room = line[i:len(line)]
			while j < total:
				if room.find(info[j]["nbr"]) == 0:
					moves[k]["room"].append(info[j]["nbr"])
				j += 1
			while i < len(line) and line[i] != ' ':
				i += 1
		elif line[i] == ' ' and l_found == True and ant_found == True and room_found == True:
			l_found = False
			ant_found = False
			room_found = False
			i += 1
		else:
			return (False)
	if len(line) == 0:
		return (False)
	return (True)

def main(argv, argc):
	if argc == 1:
		data=sys.stdin.read().splitlines()
		info = dict()
		moves = dict()
		start = "N"
		end = "N"
		ants = 0
		i = 0
		k = 0
		total = 0
		coordinates_found = False
		for line in data:
			print (line)
			if line == "##start":
				if start == "N":
					start = "F"
				else:
					print ("Error")
			elif line == "##end":
				if end == "N":
					end = "F"
				else:
					print ("Error")
			if line.isnumeric() == True:
				ants = line
			elif check_if_coordinates(line) == True:
				nbr = line[0:line.find(" ")]
				x = int(line[line.find(" ") + 1:line.rfind(" ")])
				y = int(line[line.rfind(" ") + 1:len(line)])
				total += 1
				if start == "F":
					start = nbr
				if end == "F":
					end = nbr
				info[i] = {"nbr": nbr, "x": x, "y": y, "connect": [], "total": total, "grid_x": 0, "grid_y": 0}
				i += 1
				coordinates_found = True
			elif check_if_connection(line) == True:
				i = 0
				nbr = line[0:line.find("-")]
				while info[i]["nbr"] != nbr:
					i += 1
				info[i]["connect"].append(line[line.find("-") + 1:len(line)])
			elif coordinates_found == True and check_if_ants_move(line, ants, info, total) == True:
				moves[k] = {"ant": [], "room": [], "total": 0, "total_ants": ants}
				collect_ant_move(line, ants, info, total, moves, k)
				print(moves[k])
				k += 1
		i = 0
		while i < total:
			info[i]["total"] = total
			i += 1
		i = 0
		while i < k:
			moves[i]["total"] = k
			i += 1
		make_map(start, end, info, moves)
	else:
		print("Usage: ./lem-in < maps/subject3.map | ./visu-hex")

if __name__ == "__main__":
	main(sys.argv, len(sys.argv))


#
#make dict for coordinatees and one for connections
#koordinates for each one of them
#
#ants
#koordinates
#	nbr: 0(or "start or "end)
#	x: 15
#	y: 20
#	connect: nbr or end
#	total: 0
#
#kombinations
#	each nbr add the ones it is connected to aka array thingy as i had in minisynth
#	


#
#
#TO DO
#
#collect info about the ants moves and move accordingly
#
#add arrow key commands
# speed up and down, autoplay with space bar, reset and arrow keys forward and backwards
#